use std::cell::OnceCell;
use std::collections::BTreeMap;

use super::Instruction;

const NAME_ONCE_CELL: OnceCell<BTreeMap<&'static str, &'static str>> = OnceCell::new();
const NAME_MAPPING: &[(&'static str, &'static str)] = &[
    ("abs.d", "Absolute value of double"), 
    ("abs.ps", "Absolute value of paired single"), 
    ("abs.s", "Absolute value of float"), 
    ("add", "Add word"), 
    ("add.d", "Add double"), 
    ("add.ps", "Add paired single"), 
    ("add.s", "Add float"), 
    ("addi", "Add immediate word"), 
    ("addiu", "Add immediate unsigned word"), 
    ("addiupc", "Add immediate unsigned to PC"), 
    ("addu", "Add unsigned word"),
    ("align", "Concatenate two GPRs, and extract a contiguous subset at byte position"), 
    ("alnv.ps", "Floating point align variable"), 
    ("aluipc", "Aligned add upper immediate to PC"), 
    ("and", "And word"), 
    ("andi", "And immediate word"), 
    ("aui", "Add upper immediate word"), 
    ("auipc", "Add upper immediate to PC"), 
    ("b", "Unconditional branch"), 
    ("bal", "Branch and link"), 
    ("balc", "Branch and link compact"), 
    ("bc", "Branch compact"), 
    ("bc1eqz", "Branch if coprocessor 1 register bit 0 equal to zero"), 
    ("bc1f", "Branch if floating point false"), 
    ("bc1fl", "Branch if floating point false, likely"), 
    ("bc1nez", "Branch if coprocessor 1 register bit 0 not equal to zero"), 
    ("bc1t", "Branch if floating point true"), 
    ("bc1tl", "Branch if floating point true, likely"), 
    ("bc2eqz", "Branch if coprocessor 2 condition equal to zero"), 
    ("bc2f", "Branch if coprocessor 2 false"), 
    ("bc2fl", "Branch if coprocessor 2 false, likely"), 
    ("bc2nez", "Branch if coprocessor 2 condition equal to zero"), 
    ("bc2t", "Branch if coprocessor 2 true"), 
    ("bc2tl", "Branch if coprocessor 2 true, likely"), 
    ("beq", "Branch if equal"), 
    ("beqc", "Branch if equal, compact"),
    ("beql", "Branch if equal, likely"), 
    ("beqz", "Branch if equal to zero"), 
    ("beqzalc", "Branch if equal to zero and link, compact"), 
    ("beqzc", "Branch if equal to zero, compact"), 
    ("beqzl", "Branch if equal to zero, likely"), 
    ("bgec", "Branch if greater than or equal, compact"), 
    ("bgeuc", "Branch if unsigned greater than or equal, compact"), 
    ("bgez", "Branch if greater than or equal to zero"), 
    ("bgezal", "Branch if greater than or equal to zero and link"), 
    ("bgezalc", "Branch if greater than or equal to zero and link, compact"), 
    ("bgezall", "Branch if greater than or equal to zero and link, likely"), 
    ("bgezc", "Branch if greater than or equal to zero, compact"), 
    ("bgezl", "Branch if greater than or equal to zero, likely"), 
    ("bgtc", "Branch if greater than, compact"), 
    ("bgtuc", "Branch if unsigned greater than, compact"), 
    ("bgtz", "Branch if greater than zero"), 
    ("bgtzalc", "Branch if greater than zero and link, compact"), 
    ("bgtzc", "Branch if greater than zero, compact"), 
    ("bgtzl", "Branch if greater than zero, likely"), 
    ("bitswap", "Bitswap"), 
    ("blec", "Branch if less than or equal, compact"), 
    ("bleuc", "Branch if unsigned less than or equal, compact"), 
    ("blez", "Branch if less than or equal to zero"), 
    ("blezalc", "Branch if less than or equal to zero and link, compact"), 
    ("blezc", "Branch if less than or equal to zero, compact"), 
    ("blezl", "Branch if less than or equal to zero, likely"), 
    ("bltc", "Branch if less than, compact"), 
    ("bltuc", "Branch if unsigned less than, compact"), 
    ("bltz", "Branch if less than zero"), 
    ("bltzal", "Branch if less than zero and link"), 
    ("bltzalc", "Branch if less than zero and link, compact"), 
    ("bltzall", "Branch if less than zero and link, likely"), 
    ("bltzc", "Branch if less than zero, compact"), 
    ("bltzl", "Branch if less than zero, likely"), 
    ("bne", "Branch if not equal"), 
    ("bnec", "Branch if not equal, compact"), 
    ("bnel", "Branch if not equal, likely"), 
    ("bnezalc", "Branch if not equal to zero and link, compact"), 
    ("bnezc", "Branch if not equal to zero, compact"), 
    ("bnvc", "Branch if no overflow, compact"), 
    ("bovc", "Branch if overflow, compact"), 
    ("break", "Breakpoint"), 
    ("cache", "Cache operation"), 
    ("ceil.l.d", "Ceiling double to long"), 
    ("ceil.l.s", "Ceiling float to long"), 
    ("ceil.w.d", "Ceiling double to word"), 
    ("ceil.w.s", "Ceiling float to word"), 
    ("cfc1", "Move control word from floating point"), 
    //("cfc2", "Move control word from coprocessor 2"), 
    ("class.d", "Scalar double class mask"), 
    ("class.s", "Scalar floating-point class mask"), 
    ("clo", "Count leading ones in word"), 
    ("clz", "Count leading zeros in word"), 
    //("cop2", "Coprocessor 2 operation"), 
    ("crc32b", "Cyclic redundancy check for byte"), 
    ("crc32cb", "Cyclic redundancy check (Castagnoli) for byte"), 
    ("crc32ch", "Cyclic redundancy check (Castagnoli) for halfword"), 
    ("crc32cw", "Cyclic redundancy check (Castagnoli) for word"), 
    ("crc32h", "Cyclic redundancy check for halfword"), 
    ("crc32w", "Cyclic redundancy check for word"), 
    ("ctc1", "Move control word to floating point"), 
    //("ctc2", "Move control word to coprocessor 2"), 
    ("cvt.d.l", "Convert long to double"), 
    ("cvt.d.s", "Convert float to double"), 
    ("cvt.d.w", "Convert word to double"), 
    ("cvt.l.d", "Convert double to long"), 
    ("cvt.l.s", "Convert float to long"), 
    ("cvt.ps.s", "Convert pair to paired single"), 
    ("cvt.s.d", "Convert double to float"), 
    ("cvt.s.l", "Convert long to float"), 
    ("cvt.s.pl", "Convert paired lower to single"), 
    ("cvt.s.pu", "Convert paired upper to single"), 
    ("cvt.s.w", "Convert word to float"), 
    ("cvt.w.d", "Convert double to word"), 
    ("cvt.w.s", "Convert float to word"), 
    ("deret", "Debug exception return"), 
    ("di", "Disable interrupts"), 
    ("div", "Divide word"), 
    ("div.d", "Divide double"), 
    ("div.ps", "Divide paired single"), 
    ("div.s", "Divide float"), 
    ("divu", "Divide word unsigned"), 
    ("dvp", "Disable virtual processor"), 
    ("ehb", "Execution hazard barrier"), 
    ("ei", "Enable interrupts"), 
    ("eret", "Exception return"), 
    ("eretnc", "Exception return, no clear"), 
    ("evp", "Enable virtual processor"), 
    ("ext", "Extract bit field"), 
    ("floor.l.d", "Floor double to long"), 
    ("floor.l.s", "Floor float to long"), 
    ("floor.w.d", "Floor double to word"), 
    ("floor.w.s", "Floor float to word"), 
    ("ginvi", "Global invalidate instruction cache"), 
    ("ginvt", "Global invalidate TLB"), 
    ("ins", "Insert bit field"), 
    ("j", "Jump"), 
    ("jal", "Jump and link"), 
    ("jalr", "Jump to register and link"), 
    ("jalr.hb", "Jump to register and link with hazard barrier"), 
    ("jalx", "Jump and link exchange"), 
    ("jialc", "Jump indexed and link, compact"), 
    ("jialx", "Jump indexed and link exchange"), 
    ("jic", "Jump indexed, compact"), 
    ("jr", "Jump to register"), 
    ("jr.hb", "Jump to register with hazard barrier"), 
    ("la", "Load address"), 
    ("lb", "Load byte"), 
    ("lbu", "Load byte unsigned"), 
    ("ldc1", "Load doubleword to floating point"), 
    ("ldc2", "Load doubleword to coprocessor 2"), 
    ("ldxc1", "Load doubleword indexed to floating point"), 
    ("lh", "Load halfword"), 
    ("lhu", "Load halfword unsigned"), 
    ("ll", "Load linked word"), 
    ("llwp", "Load linked word paired"), 
    ("lsa", "Load scaled address"), 
    ("lui", "Load upper immediate"), 
    ("luxc1", "Load doubleword indexed unaligned to floating point"), 
    ("lw", "Load word"), 
    ("lwc1", "Load word to floating point"), 
    ("lwc2", "Load word to coprocessor 2"), 
    ("lwl", "Load word left"), 
    ("lwpc", "Load word PC-relative"), 
    ("lwr", "Load word right"), 
    ("lwu", "Load word unsigned"), 
    ("lwxc1", "Load word indexed to floating point"), 
    ("madd", "Multiply add to hi, lo"), 
    ("madd.d", "Multiply add double"), 
    ("madd.ps", "Multiply add paired single"), 
    ("madd.s", "Multiply add float"), 
    ("maddf.d", "Multiply add double, fused"), 
    ("maddf.s", "Multiply add float, fused"), 
    ("maddu", "Multiply add unsigned to hi, lo"), 
    ("max.d", "Floating point double maximum"), 
    ("max.s", "Floating point maximum"), 
    ("maxa.d", "Floating point double absolute maximum"), 
    ("maxa.s", "Floating point absolute maximum"), 
    ("mfc0", "Move from coprocessor 0"), 
    ("mfc1", "Move from coprocessor 1"), 
    //("mfc2", "Move from coprocessor 2"), 
    ("mfhc0", "Move from high coprocessor 0"), 
    ("mfhc1", "Move from high coprocessor 1"), 
    //("mfhc2", "Move from high coprocessor 2"), 
    ("mfhi", "Move from Hi register"), 
    ("mflo", "Move from Lo register"), 
    ("min.d", "Floating point double minimum"), 
    ("min.s", "Floating point minimum"), 
    ("mina.d", "Floating point double absolute minimum"), 
    ("mina.s", "Floating point absolute minimum"), 
    ("mod", "Modulo word"), 
    ("modu", "Modulo word unsigned"), 
    ("mov.d", "Move double"), 
    ("mov.ps", "Move paired single"), 
    ("mov.s", "Move float"), 
    ("movf", "Move if floating point false"), 
    ("movf.d", "Move double if floating point false"), 
    ("movf.ps", "Move paired single if floating point false"), 
    ("movf.s", "Move float if floating point false"), 
    ("movn", "Move if not zero"), 
    ("movn.d", "Move double if GPR not zero"), 
    ("movn.ps", "Move float if GPR not zero"), 
    ("movn.s", "Move float if GPR not zero"), 
    ("movt", "Move if floating point true"), 
    ("movt.d", "Move double if floating point true"), 
    ("movt.ps", "Move paired single if floating point true"), 
    ("movt.s", "Move float if floating point true"), 
    ("movz", "Move if zero"), 
    ("movz.d", "Move double if GPR zero"), 
    ("movz.ps", "Move paired single if GPR zero"), 
    ("movz.s", "Move float if GPR zero"), 
    ("msub", "Multiply subtract from hi, lo"), 
    ("msub.d", "Multiply subtract double"), 
    ("msub.ps", "Multiply subtract paired single"), 
    ("msub.s", "Multiply subtract float"), 
    ("msubf.d", "Multiply subtract double, fused"), 
    ("msubf.s", "Multiply subtract float, fused"), 
    ("msubu", "Multiply subtract unsigned from hi, lo"), 
    ("mtc0", "Move to coprocessor 0"), 
    ("mtc1", "Move to coprocessor 1"), 
    //("mtc2", "Move to coprocessor 2"), 
    ("mthc0", "Move to high coprocessor 0"), 
    ("mthc1", "Move to high coprocessor 1"), 
    //("mthc2", "Move to high coprocessor 2"), 
    ("mthi", "Move to Hi register"), 
    ("mtlo", "Move to Lo register"), 
    ("muh", "Multiply word, high word"), 
    ("muhu", "Multiply word unsigned, high word"), 
    ("mul", "Multiply word, low word"), 
    ("mul.d", "Multiply double"), 
    ("mul.ps", "Multiply paired single"), 
    ("mul.s", "Multiply float"), 
    ("mult", "Multiply word to Hi, Lo"), 
    ("multu", "Multiply word unsigned to Hi, Lo"), 
    ("mulu", "Multiply word unsigned, low word"), 
    ("nal", "No operation and link"), 
    ("neg.d", "Negate double"), 
    ("neg.ps", "Negate paired single"), 
    ("neg.s", "Negate float"), 
    ("nmadd.d", "Negative multiply add double"), 
    ("nmadd.ps", "Negative multiply add paired single"), 
    ("nmadd.s", "Negative multiply add float"), 
    ("nmsub.d", "Negative multiply subtract double"), 
    ("nmsub.ps", "Negative multiply subtract paired single"), 
    ("nmsub.s", "Negative multiply subtract float"), 
    ("nop", "No operation"), 
    ("nor", "Not or word"), 
    ("or", "Or word"), 
    ("ori", "Or word immediate"), 
    ("pause", "Pause for LLBit"), 
    ("pll.ps", "Paired lower lower"), 
    ("plu.ps", "Paired lower upper"), 
    ("pref", "Prefetch"), 
    ("prefx", "Prefetch indexed"), 
    ("pul.ps", "Paired upper lower"), 
    ("puu.ps", "Paired upper upper"), 
    ("rdhwr", "Read hardware register"), 
    ("rdpgpr", "Read previous GPR"), 
    ("recip.d", "Reciprocal double"), 
    ("recip.s", "Reciprocal float"), 
    ("rint.d", "Round double to int"), 
    ("rint.s", "Round float to int"), 
    ("rotr", "Rotate right"), 
    ("rotrv", "Rotate right variable"), 
    ("round.l.d", "Round double to long"), 
    ("round.l.s", "Round float to long"), 
    ("round.w.d", "Round double to word"), 
    ("round.w.s", "Round float to word"), 
    ("rsqrt.d", "Reciprocal square root double"), 
    ("rsqrt.s", "Reciprocal square root float"), 
    ("sb", "Store byte"), 
    ("sc", "Store conditional word"), 
    ("scwp", "Store conditional word paired"), 
    ("sdbbp", "Software debug breakpoint"), 
    ("sdc1", "Store doubleword from floating point"), 
    ("sdc2", "Store doubleword from coprocessor 2"), 
    ("sdxc1", "Store doubleword indexed from floating point"), 
    ("seb", "Sign extend byte"), 
    ("seh", "Sign extend halfword"), 
    ("sel.d", "Select double with FP condition"), 
    ("sel.ps", "Select paired single with FP condition"), 
    ("sel.s", "Select float with FP condition"), 
    ("seleqz", "Select GPR if equal to zero, else zero"), 
    ("seleqz.d", "Select double if bit 0 equal to zero, else zero"), 
    ("seleqz.s", "Select float if bit 0 equal to zero, else zero"), 
    ("selnez", "Select GPR if not equal to zero, else zero"), 
    ("selnez.d", "Select double if bit 0 not equal to zero, else zero"), 
    ("selnez.s", "Select float if bit 0 not equal to zero, else zero"), 
    ("sh", "Store halfword"), 
    ("sigrie", "Signal reserved instruction exception"), 
    ("sll", "Shift left logical"), 
    ("sllv", "Shift left logical, variable"), 
    ("slt", "Set if less than"), 
    ("slti", "Set if less than immediate"), 
    ("sltiu", "Set if unsigned less than immediate"), 
    ("sltu", "Set if unsigned less than"), 
    ("sqrt.d", "Square root double"), 
    ("sqrt.s", "Square root float"), 
    ("sra", "Shift right arithmetic"), 
    ("srav", "Shift right arithmetic, variable"), 
    ("srl", "Shift right logical"), 
    ("srlv", "Shift right logical, variable"), 
    ("ssnop", "Superscalar no operation"), 
    ("sub", "Subtract word"), 
    ("sub.d", "Subtract double"), 
    ("sub.ps", "Subtract paired single"), 
    ("sub.s", "Subtract float"), 
    ("subu", "Subtract word unsigned"), 
    ("suxc1", "Store doubleword indexed unaligned from floating point"), 
    ("sw", "Store word"), 
    ("swc1", "Store word from floating point"), 
    ("swc2", "Store word from coprocessor 2"), 
    ("swl", "Store word left"), 
    ("swr", "Store word right"), 
    ("swxc1", "Store word indexed from floating point"), 
    ("sync", "Synchronize shared memory"), 
    ("synci", "Synchronize caches to make writes effective"), 
    ("syscall", "System call"), 
    ("teq", "Trap if equal"), 
    ("teqi", "Trap if equal immediate"), 
    ("tge", "Trap if greater than or equal"), 
    ("tgei", "Trap if greater than or equal to immediate"), 
    ("tgeiu", "Trap if unsigned greater than or equal to immediate"), 
    ("tgeu", "Trap if unsigned greater than or equal"), 
    ("tlbinv", "TLB invalidate"), 
    ("tlbinvf", "TLB invalidate flush"), 
    ("tlbp", "TLB probe for matching entry"), 
    ("tlbr", "TLB read indexed entry"), 
    ("tlbwi", "TLB write indexed entry"), 
    ("tlbwr", "TLB write random entry"), 
    ("tlt", "Trap if less than"), 
    ("tlti", "Trap if less than immediate"), 
    ("tltiu", "Trap if unsigned less than immediate"), 
    ("tltu", "Trap if unsigned less than"), 
    ("tne", "Trap if not equal"), 
    ("tnei", "Trap if not equal to immediate"), 
    ("trunc.l.d", "Truncate double to long"), 
    ("trunc.l.s", "Truncate float to long"), 
    ("trunc.w.d", "Truncate double to word"), 
    ("trunc.w.s", "Truncate float to word"), 
    ("wait", "Enter standby mode"), 
    ("wrpgpr", "Write to GPR previous shadow set"), 
    ("wsbh", "Word swap bytes within halfwords"), 
    ("xor", "Exclusive or"), 
    ("xori", "Exclusive or immediate")
];

impl Instruction {
    pub fn get_name_meaning(name: &str) -> Option<&'static str> {
        Some(
            NAME_MAPPING[NAME_MAPPING
                .binary_search_by(|probe| probe.0.cmp(name))
                .ok()?]
            .1,
        )
    }
    pub fn get_name(name: &str) -> Option<&'static str> {
        Some(
            NAME_MAPPING[NAME_MAPPING
                .binary_search_by(|probe| probe.0.cmp(name))
                .ok()?]
            .0,
        )
    }
}

#[cfg(test)]
#[test]
fn test_name_mapping_sorted() {
    let mut mapping = NAME_MAPPING.iter().map(|v| *v).collect::<Vec<(&'static str, &'static str)>>();
    mapping.sort_by_key(|c| c.0);
    println!("{:?}", mapping);
    assert!(NAME_MAPPING.iter().map(|v| v.0).is_sorted());

}